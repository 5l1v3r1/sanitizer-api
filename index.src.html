<pre class="metadata">
Title: Sanitize Untrusted HTML
Status: DREAM
Shortname: SANITIZE
Level: 1
Editor: Mike West 56384, Google Inc., mkwst@google.com
Abstract:
  This document specifies a set of APIs which allow developers to take untrusted
  strings of HTML, and sanitize them for safe insertion into a document's DOM.
Indent: 2
Boilerplate: omit conformance, omit feedback-header
Markup Shorthands: css off, markdown on
</pre>
<pre class="anchors">
spec: URL; urlPrefix: https://url.spec.whatwg.org/
  type: dfn
    text: URL parser; url: concept-url-parser
    text: URL serializer; url: concept-url-serializer
  type: attribute
    text: host; for: URL; url: concept-url-host
    text: port; for: URL; url: concept-url-port
    text: path; for: URL; url: concept-url-path
    text: origin; for: URL; url: concept-url-origin
    text: scheme; for: URL; url: concept-url-scheme
  type: interface;
    text: URL
spec: HTML; urlPrefix: https://html.spec.whatwg.org/
  type: interface
    text: Document; url: document
spec: DOM-PARSING; urlPrefix: https://w3c.github.io/DOM-Parsing/
  type: attribute
    text: innerHTML; for: Element; url: #widl-Element-innerHTML
text: window.toStaticHTML(); type: method; url: https://msdn.microsoft.com/en-us/library/cc848922(v=vs.85).aspx
</pre>
<pre class="biblio">
{
  "DOMPURIFY": {
    "href": "https://github.com/cure53/DOMPurify",
    "title": "DOMPurify",
    "publisher": "Cure53"
  }
}
</pre>
<style>
  ul.toc ul ul ul {
    margin: 0 0 0 2em;
  }
  ul.toc ul ul ul span.secno {
    margin-left: -9em;
  }
</style>

Introduction {#intro}
=====================

<em>This section is not normative.</em>

Web applications often need to work with strings of HTML on the client side,
perhaps as part of a client-side templating solution, perhaps as part of
rendering user generated content, etc. It is difficult to do so in a safe way,
however; the naive approach of joining strings together and stuffing them into
an {{Element}}'s {{Element/innerHTML}} is fraught with risk, as that can and
will cause JavaScript execution in a number of unexpected ways.

Libraries like [[DOMPURIFY]] attempt to manage this problem by carefully
parsing and sanitizing strings before insertion by constructing a DOM and
walking its members through a white-list. This has proven to be a fragile
approach, as the parsing APIs exposed to the web don't always map in
reasonable ways to the browser's behavior when actually rendering a string as
HTML in the "real" DOM. Moreover, the libraries need to keep on top of
browsers' changing behavior over time; things that once were safe may turn
into time-bombs based on new platform-level features.

The browser, on the other, has an fairly good idea of when it is going to
execute code. We can improve upon the userspace libraries by teaching the
browser how to render HTML from an arbitrary string in a safe manner, and do
so in a way that is much more likely to be maintained and updated along with
the browser's own changing parser implementation. This document outlines an
API which aims to do just that.

Goals {#goals}
--------------

*   Mitigate the risk of DOM-based cross-site scripting attacks by providing
    developers with mechanisms for handling user-controlled HTML which prevent
    direct script execution upon injection.
    
*   Enable browser-based crypto software to sanitize rich-text after decryption 
    and before additional processing in the DOM. 

Examples {#examples}
--------------------

<pre>
  Sanitizer.sanitizeString("&lt;img src=x onerror=alert(1)//&gt;") // returns `<img src="x">`
  
  Sanitizer.sanitizeNode(node); // returns sanitized DOM node
  
  Sanitizer.sanitizeDocument(doc); // returns sanitized document
</pre>

<pre>
  Sanitizer.sanitizeString("&lt;img src=x onerror=alert(1)//&gt;", configuration)
  
  Sanitizer.sanitizeNode(node, configuration);
  
  Sanitizer.sanitizeDocument(doc, configuration);
</pre>

ISSUE: Is this the API we want? How much do we care about the string itself?
Could we simply inject the string into the DOM and have the sanitization,
neutering, etc. done transparently as part of the injection? That is,
`element.totallySafeInnerHTML = badString;` rather than `element.innerHTML =
document.sanitize(badString)`?

ISSUE: More broadly, do we only care about injections, or should we attempt to
move in the direction lcamtuf@ proposed a million years ago by attaching
policies to specific pieces of the DOM (e.g.
`<div policy='no-script no-whatever'>...</div>`), which might obviate the need
to sanitize in the first place?

ISSUE: Should the sanitizer methods essentially be promises? This way we could for 
example also handle erroneous HTML, invalid nodes or any thing else that has the 
parser stumble (which might be especially interesting for XML and XML-nodes / 
-documents) more elegantly.

Framework {#framework}
======================

Blah, blah, blah.

Acknowledgements {#ack}
=======================

Cure53's [[DOMPURIFY]] is a clear inspiration for the API this document
describes, as is Internet Explorer's {{window.toStaticHTML()}}.
